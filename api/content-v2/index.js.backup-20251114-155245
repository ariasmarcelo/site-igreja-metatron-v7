const { createClient } = require('@supabase/supabase-js');
const { open } = require('lmdb');
const path = require('path');

const supabaseUrl = process.env.VITE_SUPABASE_URL;
const supabaseKey = process.env.SUPABASE_SERVICE_KEY || process.env.VITE_SUPABASE_ANON_KEY;
const supabase = createClient(supabaseUrl, supabaseKey);

function log(msg) {
  console.log(`[${new Date().toISOString()}] ${msg}`);
}

function getDB() {
  if (!global.__lmdbInstance) {
    const dbPath = path.join(process.cwd(), '.cache', 'content-lmdb');
    global.__lmdbInstance = open({ 
      path: dbPath, 
      compression: true,
      noSubdir: false,
      maxReaders: 126
    });
    log(`[LMDB] Pool global inicializado: ${dbPath}`);
  }
  return global.__lmdbInstance;
}

// Load individual paths from cache (granular)
function loadPathsFromCache(paths) {
  try {
    const db = getDB();
    const results = {};
    let hits = 0;
    let misses = 0;
    
    for (const fullPath of paths) {
      const cached = db.get(fullPath);
      
      if (cached && (cached.invalidatedAt === null || cached.invalidatedAt === undefined)) {
        results[fullPath] = cached.data;
        hits++;
      } else {
        results[fullPath] = null; // Mark as cache miss
        misses++;
      }
    }
    
    log(`[CACHE] Checked ${paths.length} paths: ${hits} hits, ${misses} misses`);
    return results;
  } catch (err) {
    log(`[CACHE] ERRO ao acessar: ${err.message}`);
    return null;
  }
}

// Save individual entries to cache (granular)
function saveToCacheGranular(entries) {
  try {
    const db = getDB();
    let saved = 0;
    
    for (const entry of entries) {
      // json_key already includes pageId prefix (e.g., "purificacao.header")
      const cacheKey = entry.json_key;
      const cacheEntry = {
        data: entry.content['pt-BR'],
        invalidatedAt: null
      };
      
      db.put(cacheKey, cacheEntry);
      saved++;
    }
    
    db.flushed.then(() => {
      log(`[CACHE] Flush completo: ${saved} entries`);
    });
    
    log(`[CACHE] Saved ${saved} granular entries`);
  } catch (err) {
    log(`[CACHE] ERRO ao salvar: ${err.message}`);
  }
}

function reconstructObjectFromEntries(entries) {
  const result = {};
  
  // Sort entries by path depth (shorter paths first, so parents are created before children)
  // This ensures "purificacao.valores" is processed before "purificacao.valores.cards[0].title"
  const sortedEntries = entries.sort((a, b) => {
    const depthA = a.json_key.split('.').length;
    const depthB = b.json_key.split('.').length;
    return depthA - depthB;
  });
  
  for (const entry of sortedEntries) {
    // Remove pageId prefix from json_key (e.g., "index.hero.title" -> "hero.title")
    const keyParts = entry.json_key.split('.');
    const keys = keyParts.slice(1); // Skip first element (pageId)
    
    if (keys.length === 0) continue; // Skip if no keys after removing pageId
    
    let current = result;
    
    for (let i = 0; i < keys.length - 1; i++) {
      const key = keys[i];
      const nextKey = keys[i + 1];
      const isNextArray = /\[\d+\]/.test(nextKey);
      const arrayMatch = key.match(/^(.+)\[(\d+)\]$/);
      
      if (arrayMatch) {
        const arrayName = arrayMatch[1];
        const index = parseInt(arrayMatch[2]);
        
        if (!current[arrayName]) {
          current[arrayName] = [];
        }
        
        if (!current[arrayName][index]) {
          current[arrayName][index] = isNextArray ? [] : {};
        }
        
        current = current[arrayName][index];
      } else {
        if (!current[key]) {
          current[key] = isNextArray ? [] : {};
        }
        current = current[key];
      }
    }
    
    const lastKey = keys[keys.length - 1];
    const arrayMatch = lastKey.match(/^(.+)\[(\d+)\]$/);
    
    if (arrayMatch) {
      const arrayName = arrayMatch[1];
      const index = parseInt(arrayMatch[2]);
      
      if (!current[arrayName]) {
        current[arrayName] = [];
      }
      
      current[arrayName][index] = entry.content['pt-BR'];
    } else {
      // Skip setting if already exists as object/array (parent was processed first, has children)
      if (typeof current[lastKey] === 'object' && current[lastKey] !== null) {
        continue; // Skip, children already populated this
      }
      current[lastKey] = entry.content['pt-BR'];
    }
  }
  
  return result;
}

// Load all paths for a page from DB and cache granularly
async function loadPageFromDB(pageId) {
  try {
    log(`[DB] Querying all entries for pageId=${pageId}`);
    
    const { data: entries, error } = await supabase
      .from('text_entries')
      .select('*')
      .eq('page_id', pageId);
    
    if (error) {
      log(`[DB] ERRO: ${error.message}`);
      return null;
    }
    
    if (!entries || entries.length === 0) {
      log(`[DB] No records found: pageId=${pageId}`);
      return null;
    }
    
    log(`[DB] Found ${entries.length} entries for pageId=${pageId}`);
    
    // Save to cache granularly
    saveToCacheGranular(entries);
    
    // Reconstruct page object
    const reconstructed = reconstructObjectFromEntries(entries);
    return reconstructed;
  } catch (err) {
    log(`[DB] ERRO inesperado: ${err.message}`);
    return null;
  }
}

// Load all cached paths for a page and reconstruct object
function loadPageFromCache(pageId) {
  try {
    const db = getDB();
    const allKeys = Array.from(db.getKeys());
    const pageKeys = allKeys.filter(key => typeof key === 'string' && key.startsWith(`${pageId}.`));
    
    if (pageKeys.length === 0) {
      log(`[CACHE] No entries found for pageId=${pageId}`);
      return null;
    }
    
    const entries = [];
    for (const key of pageKeys) {
      const cached = db.get(key);
      if (cached && (cached.invalidatedAt === null || cached.invalidatedAt === undefined)) {
        const jsonKey = key.substring(pageId.length + 1); // Remove "pageId." prefix
        entries.push({
          page_id: pageId,
          json_key: jsonKey,
          content: { 'pt-BR': cached.data }
        });
      }
    }
    
    if (entries.length === 0) {
      log(`[CACHE] All entries invalidated for pageId=${pageId}`);
      return null;
    }
    
    log(`[CACHE] Found ${entries.length} valid entries for pageId=${pageId}`);
    const reconstructed = reconstructObjectFromEntries(entries);
    return reconstructed;
  } catch (err) {
    log(`[CACHE] ERRO: ${err.message}`);
    return null;
  }
}

// Load specific paths from DB and cache them granularly
async function loadPathsFromDB(paths) {
  try {
    // Group paths by pageId to minimize queries
    const pathsByPage = new Map();
    for (const fullPath of paths) {
      const parts = fullPath.split('.');
      const pageId = parts[0];
      const jsonKey = parts.slice(1).join('.');
      
      if (!pathsByPage.has(pageId)) {
        pathsByPage.set(pageId, []);
      }
      pathsByPage.get(pageId).push({ fullPath, jsonKey });
    }
    
    const results = {};
    
    // Query each page's paths
    for (const [pageId, pathList] of pathsByPage.entries()) {
      // json_key in DB includes pageId prefix, e.g., "purificacao.header"
      const jsonKeys = pathList.map(p => `${pageId}.${p.jsonKey}`);
      
      log(`[DB] Querying Supabase: pageId=${pageId}, paths=${jsonKeys.length}`);
      
      const { data: entries, error } = await supabase
        .from('text_entries')
        .select('*')
        .eq('page_id', pageId)
        .in('json_key', jsonKeys);
      
      if (error) {
        log(`[DB] ERRO: ${error.message}`);
        continue;
      }
      
      if (!entries || entries.length === 0) {
        log(`[DB] No records found: pageId=${pageId}`);
        for (const { fullPath } of pathList) {
          results[fullPath] = undefined;
        }
        continue;
      }
      
      log(`[DB] Found ${entries.length} entries for pageId=${pageId}`);
      
      // Save to cache granularly and build results
      saveToCacheGranular(entries);
      
      for (const entry of entries) {
        // json_key already includes pageId prefix (e.g., "purificacao.header")
        const fullPath = entry.json_key;
        results[fullPath] = entry.content['pt-BR'];
      }
    }
    
    return results;
  } catch (err) {
    log(`[DB] ERRO inesperado: ${err.message}`);
    return null;
  }
}

module.exports = async (req, res) => {
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');

  if (req.method === 'OPTIONS') {
    return res.status(200).end();
  }

  if (req.method !== 'GET') {
    return res.status(405).json({ success: false, message: 'Method not allowed' });
  }

  const requestStart = Date.now();
  
  try {
    const pagesParam = req.query.pages;
    const pathsParam = req.query.paths;
    
    // Mode 1: Full pages (?pages=index OR ?pages=purificacao,testemunhos)
    if (pagesParam && !pathsParam) {
      const pageIds = pagesParam.split(',').map(p => p.trim().toLowerCase()).filter(Boolean);
      
      if (pageIds.length === 0) {
        log(`[REQUEST] ERRO: pages parameter empty`);
        return res.status(400).json({ 
          success: false, 
          message: 'Pages parameter is empty' 
        });
      }
      
      log(`[REQUEST] GET pages=${pageIds.join(',')}`);
      
      const results = {};
      const sources = {};
      
      for (const pageId of pageIds) {
        let pageContent = loadPageFromCache(pageId);
        
        if (pageContent) {
          results[pageId] = pageContent;
          sources[pageId] = 'cache';
        } else {
          pageContent = await loadPageFromDB(pageId);
          if (pageContent) {
            results[pageId] = pageContent;
            sources[pageId] = 'db';
          } else {
            results[pageId] = null;
            sources[pageId] = 'not-found';
          }
        }
      }
      
      const duration = Date.now() - requestStart;
      log(`[RESPONSE] 200 OK: pages=${pageIds.join(',')}, duration=${duration}ms`);
      
      return res.status(200).json({
        success: true,
        pages: results,
        sources: sources
      });
    }
    
    // Mode 2: Granular paths (?paths=purificacao.header,purificacao.intro.title)
    if (pathsParam) {
      const paths = pathsParam.split(',').map(p => p.trim().toLowerCase()).filter(Boolean);
      
      if (paths.length === 0) {
        log(`[REQUEST] ERRO: paths parameter empty`);
        return res.status(400).json({ 
          success: false, 
          message: 'Paths parameter is empty' 
        });
      }
      
      log(`[REQUEST] GET GRANULAR paths=${paths.join(',')}`);
      
      // Try loading from cache (granular)
      const cacheResults = loadPathsFromCache(paths);
      const results = {};
      const sources = {};
      const missingPaths = [];
      
      if (cacheResults) {
        for (const fullPath of paths) {
          if (cacheResults[fullPath] !== null) {
            results[fullPath] = cacheResults[fullPath];
            sources[fullPath] = 'cache';
          } else {
            missingPaths.push(fullPath);
          }
        }
      } else {
        // Cache error, load all from DB
        missingPaths.push(...paths);
      }
      
      // Load missing paths from DB
      if (missingPaths.length > 0) {
        log(`[API] Loading ${missingPaths.length} missing paths from DB`);
        const dbResults = await loadPathsFromDB(missingPaths);
        
        if (dbResults) {
          for (const fullPath of missingPaths) {
            results[fullPath] = dbResults[fullPath];
            sources[fullPath] = 'db';
          }
        }
      }

      const duration = Date.now() - requestStart;
      const cacheHits = Object.values(sources).filter(s => s === 'cache').length;
      const dbHits = Object.values(sources).filter(s => s === 'db').length;
      log(`[RESPONSE] 200 OK GRANULAR: ${paths.length} paths, ${cacheHits} cache, ${dbHits} db, duration=${duration}ms`);

      return res.status(200).json({
        success: true,
        data: results,
        sources: sources
      });
    }
    
    // No valid parameter provided
    log(`[REQUEST] ERRO: missing pages or paths parameter`);
    return res.status(400).json({ 
      success: false, 
      message: 'Query parameter "pages" or "paths" is required. Examples: ?pages=index OR ?paths=purificacao.hero,purificacao.intro' 
    });
    
  } catch (err) {
    const duration = Date.now() - requestStart;
    log(`[RESPONSE] 500 ERROR: ${err.message}, duration=${duration}ms`);
    res.status(500).json({ success: false, message: err.message });
  }
};

// Helper function to get nested value from object using dot notation
function getNestedValue(obj, path) {
  if (!path) return obj;
  
  const parts = path.split('.');
  let current = obj;
  
  for (const part of parts) {
    if (current == null || typeof current !== 'object') {
      return undefined;
    }
    current = current[part];
  }
  
  return current;
}
